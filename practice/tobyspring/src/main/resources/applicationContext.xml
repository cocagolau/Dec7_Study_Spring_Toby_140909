<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost/springbooktest" />
		<property name="username" value="spring" />
		<property name="password" value="book" />
	</bean>
	
	<!-- 새로운 jdbcContext를 bean으로 등록 -->
	
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>	
	<bean id="mailSender" class="me.dec7.user.service.DummyMailSender" />
	
	
	<!-- 
		자동 프록시 생성기 <DefaultAdvisorAutoProxyCreator>는 등록된 bean 중에서
		Advisor interface를 구현할 것을 모두 찾음
		
		그리고, 생성되는 모든 bean에 대해 advisor의 pointcut을 적용해 보면서 proxy 적용 대상을 선정
		bean 클래스가 proxy선정 대상일 경우 proxy를 만들어 원래 bean 오브젝트로 바꿔치기함
		 - 원래 bean 오브젝트는 proxy 뒤에 연결돼서 proxy를 통해서만 접근 가능하게 바꾸는 것
		 - target bean에 의존한다고 정의한 다른 bean은 proxy 오브젝트를 대신 DI 받게 될 것
	 -->
	<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" />
	
	<!-- pointcut 등록 -->
	<!--
	<bean id="transactionPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut">
		<property name="mappedName" value="upgrade*" />
	</bean>
	-->

	<!-- 
		AspectJ 적용하기 위해 기존 pointcut bean 제거
		
	<bean id="transactionPointcut" class="me.dec7.user.service.NameMatchClassMedthodPointcut">
		<!-- class 이름 패턴 
		<property name="mappedClassName" value="*ServiceImpl" />
		<!-- method 이름 패턴
		<property name="mappedName" value="upgrade*" />
	</bean>
	-->
	
	<!-- 
	 * AOP namespace
	 * 
	 * aop scheme
	 * 	- spring은 AOP에 관련된 태그를 정의
	 * 	- spring에서 AOP를 위해 기계적으로 적용하는 bean을 간편하게 등록할 수 있음

	<aop:config>
		<!-- expression의 표현식 property로 가진 AspectJExpressionPointcut을 bean으로 등록
		<aop:pointcut id="transactionPointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))" />
		
		<!-- advice와 pointcut을 property로 가지는 DefaultBeanFactoryPointcutAdvisor를 등록
		<aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut" />
	</aop:config>
	
	 * advisor 내장 포인트컷 -->
	<aop:config>
		<aop:advisor advice-ref="transactionAdvice" pointcut="execution(* *..*ServiceImpl.upgrade*(..))" />
	</aop:config>
	
	<bean id="transactionAdvice" class="me.dec7.user.service.TransactionAdvice">
		<property name="transactionManager" ref="transactionManager" />
	</bean>

	<!-- 
	<bean id="transactionPointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
		<property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))" />
	</bean>
	<bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
		<property name="advice" ref="transactionAdvice" />
		<property name="pointcut" ref="transactionPointcut" />
	</bean>
	 -->
	
	<!--
		ProxyFactoryBean 제거
		DefaultAdvisorAutoProxyCreator에 의해 자동 수집
		  
	<bean id="userService" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target" ref="userServiceImpl" />
		<property name="interceptorNames">
			<list>
				<value>transactionAdvisor</value>
			</list>
		</property>
	</bean>
	-->
	<!--
		<bean id="userServiceImpl" class="me.dec7.user.service.UserServiceImpl">
		proxy를 도입했을 때 간접적으로 사용돼야 했던 userServiceImpl을 원복
	-->
	<bean id="userService" class="me.dec7.user.service.UserServiceImpl">
		<property name="userDao" ref="userDao" />
		<property name="mailSender" ref="mailSender" />
	</bean>
	

	<bean id="userDao" class="me.dec7.user.dao.UserDaoJdbc">
		<property name="dataSource" ref="dataSource" />
	</bean>

</beans>
